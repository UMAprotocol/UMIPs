## Headers

| UMIP-130            |                                                                                 |
| ------------------- | ------------------------------------------------------------------------------- |
| UMIP Title          | Add PUNKETH-1221 as supported price identifier                                  |
| Authors             | Ross (ross@yam.finance), Chase Coleman (chase@umaproject.org)                   |
| Status              | Approved                                                                       |
| Created             | Sept. 15, 2021                                                                  |
| Discourse Link      | https://discourse.umaproject.org/t/add-update-upunks-1221-price-identifier/1335 |


# Summary

This UMIP introduces a new price identifier called `PUNKETH-1221` for a token referred to as `uPUNKS`. The token is a synthetic index based on the recent trading prices of CryptoPunks. The previous price identifiers ```PUNKETH``` and ```PUNKETH_TWAP``` found in [UMIP 84](./umip-84.md) are not being re-used due to the fact that the EMP contract cannot use ancilliary data and without that we cannot create multiple overlapping uPUNK contracts. The logic of the previous price identifiers is being mostly re-used with variable timestamps instead of seperate price identifiers.

The structure of this price identifier mimics (in some ways) the ones created for `uGAS` ([UMIP 16](./UMIP-16.md), [UMIP 20](./UMIP-20.md), [UMIP 22](./UMIP-22.md))

The DVM should support requests for a price that resolves to either the median most recent purchase price (in ETH) of each unique CryptoPunk traded in the last 30 days, or a 2-hour Time-Weighted Average Price (TWAP) of the highest volume Uniswap or sushiswap ETH/uPUNK pool (for a specified iteration of uPUNK, i.e. uPUNK-1221). The price resolution method to use will depend on the the timestamp the price request was made at.

For a price request made at or after the Unix timestamp `1640995200` (January 1, 2022 00:00:00 UTC), the price will be resolved with the median most recent purchase price (in ETH) of each unique CryptoPunk traded in the last 30 days. Full logic for this change is embedded in the Implementation section below.

For a price request made before `1640995200` (January 1, 2022 00:00:00 UTC), the price will be resolved to a 2-hour TWAP for the highest volume Uniswap/Sushiswap price of the listed synthetic token in ETH. The synthetic token address will be listed in the Technical Specification section.

# Motivation

Refer to [UMIP 84](./umip-84.md)

# Data Specifications

All relevant price data is computed using information that can be found directly on the blockchain.


The identifier requires updated timestamps.

-----------------------------------------

For a price request made at or after the Unix timestamp `1640995200` (January 1, 2022 00:00:00 UTC), the `PUNKETH-1221` price identifier depends on prices drawn from the `PunkBought` events of the CryptoPunk market contract

- Markets & Pairs: CryptoPunk Market contract `PunkBought` events. The CryptoPunk contract address is `0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB` which you can see at https://etherscan.io/address/0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb
- Example price providers: Infura and The Graph include information on CryptoPunk contract events
- Cost to use: [Infura](https://infura.io/) supports up to 100,000 requests per day for free. Information also available on [The Graph](https://thegraph.com/)
- Real-time price update frequency: Updated every block
- Historical price update frequency: Updated every block

_Note_: An important fact worth noting is that the original `CryptoPunkMarket` contract has a bug in it that results in CryptoPunk sales that are generated by "accepting a bid" to assign a value of 0 to the `value` field of the `PunkBought` event. We address this in our price feed but, if you choose to write your own implementation, it is important to be aware of this.

-----------------------------------------

For a price request made before `1640995200` (January 1, 2022 00:00:00 UTC), The `PUNKETH-1221` price identifier depends on prices generated by the Uniswap/Sushiswap pools

- Markets & Pairs: Uniswap/Sushiswap `uPUNK/ETH`
- Example price providers: The Uniswap/Sushiswap price data can be obtained directly from the blockchain
- Cost to use: [Infura](https://infura.io/) supports up to 100,000 requests per day for free. This information should also available on [The Graph](https://thegraph.com/)
- Real-time price update frequency: Updated every block
- Historical price update frequency: Updated every block


# Price Feed Implementation

The price feed methodology is very similar to that of [UMIP-84](./umip-84.md). The Pseudocode for calculating the price after expiry has been updated and is shown below:

```
# Get the PunkBought Events from the cryptopunk contract
# for the last 30 days
events = getEvents(
    w3, cryptopunk, "PunkBought",
    block_30daysago, block_now
)

# Compute the prices used for each event
events_corrected = []
for event in events:
    # Get the event that generated the transaction
    transaction = get_transaction(web3, event)

    # Decode input data to find function that
    # generated the event
    fn = cryptopunk.decode_input(transaction.input)["function_name"]
    if fn == 'buyPunk':
        # If the price was generated with `buyPunk` then the
        # value matches the price paid
        _price = event["args"]["value"]
    elif fn == 'acceptBidForPunk':
        # If the price was generated with `acceptBidForPunk` then
        # the price is inaccurate. The most succint way around this is
        # to find all of the bids made for that cryptopunk up until that
        # block and use the most recent bid (which will be the bid that
        # was accepted)
        _price = getEvents(
            w3, cryptopunk, "PunkBidEntered",
            first_block, event["block_number"],
            filters={"punkIndex": event["args"]["punkIndex"]}
        )

    # Save the relevant information
    push(events_corrected,
        {
            "punkIndex": event["args"]["punkIndex"],
            "blockNumber": event["blockNumber"],
            "price": _price
        }
    )

# Create cryptopunks array to store ids
cryptopunks = []

# Create mapping to store most recent price
cryptopunk_blockprice = {}

# Find the last PunkBought event for each CryptoPunk
for event in events_corrected:
    punk = event.punkIndex

    # Add punk to mapping if not previously added AND if price was
    # traded at is higher than 0
    if punk not in cryptopunks and event.price > 0:
        push(cryptopunks, event.punkIndex)
        cryptopunk_blockprice[event.punkIndex] = {"block": event.blockNumber, "price": event.price}

    else:
        # Find current values of block/value associated with a particular
        # cryptopunk -- Defaults to {block: 0, price: 0} if they don't exist
        current_value = {
            "block": cryptopunk_blockprice[punk]["block"]
            "price": cryptopunk_blockprice[punk]["price"]
        }

        more_recent = event.blockNumber > current_value["block"]
        price_gt_0 = event.price > 0
        if more_recent and price_gt_0:
            cryptopunk_blockprice[event.punkIndex] = {"block": event.blockNumber, "price": event.price}

# Take median of (most recent) prices
median([cryptopunk_blockprice[cryptopunk]["price"] for cryptopunk in cryptopunks])

```

A Python implementation of this pseudo-code can be found [here](https://gist.github.com/cc7768/6fd4e97aa39a0a84ae2bb00085602c9e#file-upunk_index_price-py)

The TWAP price queried prior to expiry can be determined using the existing [UniswapPriceFeed](https://github.com/UMAprotocol/protocol/blob/master/packages/financial-templates-lib/src/price-feed/UniswapPriceFeed.ts). The only required input would be determining which pool has the highest volume.

An example configuration for the Uniswap feed is below

```
"PUNKETH_TWAP": {
  type: "uniswap",
  uniswapAddress: "0x6E01DB46b183593374A49c0025e42c4bB7Ee3ffA",
  twapLength: 7200
},
```


# Technical Specifications

- Price identifier name: `PUNKETH-1221`
- Base Currency: CryptoPunk NFTs
- Quote Currency: ETH
- Rounding: Round to 6 decimal places (seventh decimal place digit >= 5 rounds up and < 5 rounds down)
- Estimated current value of post-expiry price identifier script: 0.105


# Rationale

Refer to [UMIP 84](./umip-84.md). All references to `PUNKETH` Refer to the price identifier at or after the expiry timestamp and all references to `PUNKETH_TWAP` refer to the price identifier before the expiry timestamp.


# Implementation

### After Expiry

When a price request is made, the following process should be followed:

1. Retrieve all CryptoPunk `PunkBought` events from the 30 days prior to expiration
2. Identify the last price that each CryptoPunk was traded at using the event data -- Only one price should be produced per CryptoPunk even if they had traded multiple times. Due to a [bug in the CryptoPunk Market](https://github.com/UMAprotocol/UMIPs/pull/261#discussion_r622282931), this isn't as straightforward as reading the most recent value from the `PunkBought` event. The process we use is:
    - Scan through all of the `PunkBought` events and identify the function call that generated the `PunkBought` event:
      - If it was generated by `buyPunk` then use the `PunkBought.value` price
      - If it was generated by `acceptBidForPunk` then we load all of the `PunkBidEntered` for that particular CryptoPunk and use the most recent bid (only one bid can be outstanding at a time and is always the highest)
      - In both cases, we ignore any trades that are registered with a price of 0 and look back to the most recent non-zero price.
3. Take the median of these prices - If there is an even number of prices, take the mean of the two values closest to the median.
4. Divide by 1000, and then round to 6 decimals to arrive at the final price.


**Example**

If the timestamp requested was `1619222400` then:

* We would need to identify all `PunkBought` events from `1619222400 - 30 days -> 1616630400` to `1619222400`
* Imagine that we had 5 `PunkBought` events with (`ts`, `punk_id`, `eth`) pairs of `[(1616630450, 1000, 20), (1616631450, 5000, 30), (1616631550, 5000, 35), (1618631550, 6000, 22), (1618632550, 9999, 15)]`.
* We would need to check what function generated each `PunkBought` event. Suppose they were all generated by `buyPunk`, then the prices we would use to compute the median would be `[20, 35, 22, 15]`
* There are an even number of values, so there's no "median value" in the data -- Thus we find the number between the two values closest to the median `[20, 22]` to get a price of `21`
* Divide by `1000` to get a price of `0.021`

### Before Expiry

When a price request that relies on this price identifier is made, the following process should be followed:

1. The end TWAP timestamp equals the price request timestamp.
2. The start TWAP timestamp is defined by the end TWAP timestamp - TWAP period (2 hours).
3. A single Uniswap/Sushiswap price is defined for each timestamp as the price that the ETH/uPUNK pool returns at the end of the latest block whose timestamp is less than or equal to the timestamp that is queried for.
4. The TWAP is an average of the prices for each timestamp between the start and end timestamps. Each price in this average will receive equal weight.
5. The final price should be returned with ETH


**Example**

If the timestamp requested was `1619222400` then:

* The end TWAP timestamp would be `1619222400`
* The start TWAP timestamp would be `1619222400 - 7200` -> `1619215200`
* The Uniswap price would be found for \{`1619215200`, `1619215201`, `1619215202`, ..., `1619222400`\}
* Average the prices corresponding with each price and then report this average


# Security Considerations

### After Expiry

One of the main concerns is that someone with sufficient CryptoPunks chooses to manipulate the price.

For example, there are accounts that own about 400 unique CryptoPunks and the unique number of CryptoPunks that traded in the last 30 days is about 600. An individual who owns 400 CryptoPunks and traded them amongst their own accounts at prices near zero could corrupt the price by driving it to zero after having minted and sold the tokens at a high price.

One benefit to using an oracle with human intervention is that voters could recognize this type of price manipulation and there are other viable proxies for the expected price of a CryptoPunk. For example, if voters felt like there was price manipulation, they could choose to settle the contract at the current market price of `PUNKBASIC` or other

The other main concern is if there were just insufficient CryptoPunk trades being made. If there were only 1-2 trades happening every 30 days, this index becomes much less useful because there's less information contained in its price.

### Before Expiry

The main concerns of the TWAP price are:

1. **Token price manipulation**: If the Uniswap pool is not sufficiently liquid, then attackers could try to drive down the Uniswap price and withdraw more collateral than intended. Most DeFi attacks have been done using flash loans, but flash loans would be ineffective since the price is measured at the end of each block. Collateralizaton based on the TWAP price would make it more capital intensive (and thus risky) to target the token price in this way.
2. **TWAP mismatch**: If the price of the token rises quickly then there would become a mismatch between the market price and the TWAP price. This might allow sponsers to mint tokens with less collateral than what they could sell them for on the market. Reasonable levels of collateralizaton requirements and the 2 hour "liveness period" help combat this concern.

Both of these concerns are originally discussed in [UMIP 22](./umip-22.md)
