## Headers

| UMIP-xxx            |                                                                                 |
| ------------------- | ------------------------------------------------------------------------------- |
| UMIP Title          | update PUNKETH price identifier                                  |
| Authors             | Ross (ross@yam.finance), Chase Coleman (chase@umaproject.org)                   |
| Status              |                                                                       |
| Created             | Jan. xx, 2022                                                                  |
| Discourse Link      | insert |


# Summary

This UMIP re-introduces the price identifier called `PUNKETH` for a token referred to as `uPUNKS`. The token is a synthetic index based on the recent trading prices of CryptoPunks. The previous price identifier ```PUNKETH-1221``` found in [UMIP 130](./umip-130.md) is not being re-used due to the fact that it was built for the EMP contract. This UMIP re-uses the logic of the previous ```PUNKETH``` price identifier from [UMIP 84](./umip-84.md) and uses the expiry timestamp per contract deployment to allow the creation of multiple overlapping uPUNK contracts. The ```PUNKETH_TWAP``` price identifier is being removed as the LSP is un-liquidatable and this logic is not necessary.

The DVM should support requests for a price that resolves to the median most recent purchase price (in ETH) of each unique CryptoPunk traded in the last 30 days. The price resolution method to use will depend on the the timestamp the price request was made at.

# Motivation

There are currently few synthetic non-fungible token (NFT) indexes available in the DeFi space. As NFTs continue to grow in popularity, collectors may find it useful to be able to hedge their investments and other investors may also want to gain NFT exposure without being required to purchase and maintain custody of a NFT.

Creating a CryptoPunks index before branching into other NFTs makes sense because CryptoPunks were the original NFT. As the original NFT, CryptoPunks are highly valued and relatively liquid.

1. What are the financial positions enabled by creating this synthetic that do not already exist?
  - The DVM does not currently support any NFT based indexes. This token will be the first such index and provide a template for others to be created.
2. Please provide an example of a person interacting with a contract that uses this price identifier.
  - A collector wishing to hedge the risk of purchasing a CryptoPunk could mint `uPUNK` which would provide protection against downward price movements in the value of CryptoPunks.
  - An investor who believes that the median trade price of CryptoPunks will increase could purchase `uPUNK` at its current trading price and then hold until the price appreciated.
  - An investor who believes that the median trade price of CryptoPunks will decrease could mint `uPUNK` and sell the minted tokens.

# Data Specifications

All relevant price data is computed using information that can be found directly on the blockchain.

-----------------------------------------

The `PUNKETH` price identifier depends on prices drawn from the `PunkBought` events of the CryptoPunk market contract

- Price identifier name: `PUNKETH`
- Markets & Pairs: CryptoPunk Market contract `PunkBought` events. The CryptoPunk contract address is `0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB` which you can see at https://etherscan.io/address/0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb
- Example price providers: Infura and The Graph include information on CryptoPunk contract events
- Cost to use: [Infura](https://infura.io/) supports up to 100,000 requests per day for free. Information also available on [The Graph](https://thegraph.com/)
- Real-time price update frequency: Updated every block
- Historical price update frequency: Updated every block

_Note_: An important fact worth noting is that the original `CryptoPunkMarket` contract has a bug in it that results in CryptoPunk sales that are generated by "accepting a bid" to assign a value of 0 to the `value` field of the `PunkBought` event. We address this in our price feed but, if you choose to write your own implementation, it is important to be aware of this.

# Price Feed Implementation

The price feed methodology is the same as that of [UMIP-84](./umip-84.md). The Pseudocode for calculating the price after expiry is shown below:

```
# Get the PunkBought Events from the cryptopunk contract
# for the last 30 days
events = getEvents(
    w3, cryptopunk, "PunkBought",
    block_30daysago, block_now
)

# Compute the prices used for each event
events_corrected = []
for event in events:
    # Get the event that generated the transaction
    transaction = get_transaction(web3, event)

    # Decode input data to find function that
    # generated the event
    fn = cryptopunk.decode_input(transaction.input)["function_name"]
    if fn == 'buyPunk':
        # If the price was generated with `buyPunk` then the
        # value matches the price paid
        _price = event["args"]["value"]
    elif fn == 'acceptBidForPunk':
        # If the price was generated with `acceptBidForPunk` then
        # the price is inaccurate. The most succint way around this is
        # to find all of the bids made for that cryptopunk up until that
        # block and use the most recent bid (which will be the bid that
        # was accepted)
        _price = getEvents(
            w3, cryptopunk, "PunkBidEntered",
            first_block, event["block_number"],
            filters={"punkIndex": event["args"]["punkIndex"]}
        )

    # Save the relevant information
    push(events_corrected,
        {
            "punkIndex": event["args"]["punkIndex"],
            "blockNumber": event["blockNumber"],
            "price": _price
        }
    )

# Create cryptopunks array to store ids
cryptopunks = []

# Create mapping to store most recent price
cryptopunk_blockprice = {}

# Find the last PunkBought event for each CryptoPunk
for event in events_corrected:
    punk = event.punkIndex

    # Add punk to mapping if not previously added AND if price was
    # traded at is higher than 0
    if punk not in cryptopunks and event.price > 0:
        push(cryptopunks, event.punkIndex)
        cryptopunk_blockprice[event.punkIndex] = {"block": event.blockNumber, "price": event.price}

    else:
        # Find current values of block/value associated with a particular
        # cryptopunk -- Defaults to {block: 0, price: 0} if they don't exist
        current_value = {
            "block": cryptopunk_blockprice[punk]["block"]
            "price": cryptopunk_blockprice[punk]["price"]
        }

        more_recent = event.blockNumber > current_value["block"]
        price_gt_0 = event.price > 0
        if more_recent and price_gt_0:
            cryptopunk_blockprice[event.punkIndex] = {"block": event.blockNumber, "price": event.price}

# Take median of (most recent) prices
median([cryptopunk_blockprice[cryptopunk]["price"] for cryptopunk in cryptopunks])

```

A Python implementation of this pseudo-code can be found [here](https://gist.github.com/cc7768/6fd4e97aa39a0a84ae2bb00085602c9e#file-upunk_index_price-py)


# Technical Specifications

- Price identifier name: `PUNKETH`
- Base Currency: CryptoPunk NFTs
- Quote Currency: ETH
- Rounding: Round to 6 decimal places (seventh decimal place digit >= 5 rounds up and < 5 rounds down)
- Estimated current value of post-expiry price identifier script: `enter after running`


# Rationale

The `PUNKETH` price identifier had a few decisions that we believe were important to the design:

* _CryptoPunks_: As mentioned earlier in this document, we chose to build an index using CryptoPunks because they were the original NFT. This originality has lead to them being highly valued and having consistent enough trade volume.
* _30 day median_: The 30 day median allows for the index to reflect common trading prices across many CryptoPunks rather than to respond to particular transactions
* _Unique CryptoPunks_: We only use the most recent trade price for each CryptoPunk. This is a security feature since if we used each transaction then a single person could trade one CryptoPunk amongst accounts they owned to manipulate the price.
* _Median rather than the mean_: Calculating the mean incorporates the price of every single transaction which means that someone who owned a single CryptoPunk could have a small effect on the price. The median can still be manipulated but, given the uniqueness restriction above, it would require someone to own enough CryptoPunks to make up half of the monthly transactions.


# Implementation

### After Expiry

When a price request is made, the following process should be followed:

1. Retrieve all CryptoPunk `PunkBought` events from the 30 days prior to expiration
2. Identify the last price that each CryptoPunk was traded at using the event data -- Only one price should be produced per CryptoPunk even if they had traded multiple times. Due to a [bug in the CryptoPunk Market](https://github.com/UMAprotocol/UMIPs/pull/261#discussion_r622282931), this isn't as straightforward as reading the most recent value from the `PunkBought` event. The process we use is:
    - Scan through all of the `PunkBought` events and identify the function call that generated the `PunkBought` event:
      - If it was generated by `buyPunk` then use the `PunkBought.value` price
      - If it was generated by `acceptBidForPunk` then we load all of the `PunkBidEntered` for that particular CryptoPunk and use the most recent bid (only one bid can be outstanding at a time and is always the highest)
      - In both cases, we ignore any trades that are registered with a price of 0 and look back to the most recent non-zero price.
3. Take the median of these prices - If there is an even number of prices, take the mean of the two values closest to the median.
4. Divide by 1000, and then round to 6 decimals to arrive at the final price.


**Example**

If the timestamp requested was `1619222400` then:

* We would need to identify all `PunkBought` events from `1619222400 - 30 days -> 1616630400` to `1619222400`
* Imagine that we had 5 `PunkBought` events with (`ts`, `punk_id`, `eth`) pairs of `[(1616630450, 1000, 20), (1616631450, 5000, 30), (1616631550, 5000, 35), (1618631550, 6000, 22), (1618632550, 9999, 15)]`.
* We would need to check what function generated each `PunkBought` event. Suppose they were all generated by `buyPunk`, then the prices we would use to compute the median would be `[20, 35, 22, 15]`
* There are an even number of values, so there's no "median value" in the data -- Thus we find the number between the two values closest to the median `[20, 22]` to get a price of `21`
* Divide by `1000` to get a price of `0.021`


# Security Considerations

One of the main concerns is that someone with sufficient CryptoPunks chooses to manipulate the price.

For example, there are accounts that own about 400 unique CryptoPunks and the unique number of CryptoPunks that traded in the last 30 days is about 600. An individual who owns 400 CryptoPunks and traded them amongst their own accounts at prices near zero could corrupt the price by driving it to zero after having minted and sold the tokens at a high price.

One benefit to using an oracle with human intervention is that voters could recognize this type of price manipulation and there are other viable proxies for the expected price of a CryptoPunk. For example, if voters felt like there was price manipulation, they could choose to settle the contract at the current market price of `PUNKBASIC` or other

The other main concern is if there were just insufficient CryptoPunk trades being made. If there were only 1-2 trades happening every 30 days, this index becomes much less useful because there's less information contained in its price.
